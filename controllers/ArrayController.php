<?php
/**
 * Author: jiangm
 * Email: jmphper@foxmail.com
 * Date: 2017/12/8
 * Time: 11:26
 * Desc:
 */

namespace app\controllers;

use Yii;
use yii\web\Controller;

class ArrayController extends Controller
{
    /**
     * 构造函数
     */
    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        $this->layout = false;
    }

    public function actionTest(){
        if(array()){
            echo 'if(array()) is true';
        }else{
            echo 'if(array()) is false';
        }
        echo '<br/>';

        echo '<h3>用加号合并数组</h3>';
        $array1 = ['a'=>1,'b'=>2,'c'=>3];
        $array2 = ['d'=>4,'e'=>5,'f'=>6];
        echo '<pre>';
        print_r($array1+$array2);
        echo '</pre>';
        echo '<br/>';
        $array1 = [1,2,3];
        $array2 = [4,5,6];
        echo '<pre>';
        print_r($array1+$array2);
        echo '</pre>';
        echo '<br/>';

    }

    /**
     * 数组
     * 1. 数组的key值会有些强制转换：
     * 包含有合法整型值的字符串会被转换为整型。
     * 浮点数也会被转换为整型，意味着其小数部分会被舍去
     * 布尔值也会被转换成整型。
     * Null 会被转换为空字符串
     * 数组和对象不能被用为键名
     *
     * 2. 同键名的则使用最后一个值
     * 3. PHP 数组可以同时含有 integer 和 string 类型的键名，因为 PHP 实际并不区分索引数组和关联数组。
     * 4. 
     */
    public function actionIndex(){
        
    }

    /**
     * 数组转换1
     */
    public function actionName1(){
        $arr = [
            'name' => ['aaa','bbb'],
            'is_open' => [1,2],
            'type' => [2],
        ];
        $res = [];
        $keys = array_keys($arr);
        for($i=0;$i<count(current($arr));$i++){
            $values = array_column($arr, $i);
            $res[] = array_combine($keys, $values);
        }
        echo '<pre>';
        print_r($res);
        echo '</pre>';
    }


    public function actionTree(){
        $array = [
            ['id'=>1, 'name'=>'a', 'pid'=>''],
            ['id'=>2, 'name'=>'b', 'pid'=>''],
            ['id'=>3, 'name'=>'c', 'pid'=>''],
            ['id'=>4, 'name'=>'d', 'pid'=>'1'],
            ['id'=>5, 'name'=>'e', 'pid'=>'1'],
            ['id'=>6, 'name'=>'f', 'pid'=>'1'],
            ['id'=>7, 'name'=>'g', 'pid'=>'2'],
            ['id'=>8, 'name'=>'h', 'pid'=>'2'],
            ['id'=>9, 'name'=>'i', 'pid'=>'3'],
        ];
        $tree = $this->generateTree($array);
        $tree1 = $this->getTree($array);
    }

    /**
     * 使用引用实现无限极分类
     * @param $array array
     * @return array
     */
    public function generateTree($array){
        //第一步 构造数据
        $items = array();
        foreach($array as $value){
            $items[$value['id']] = $value;
        }
        //第二部 遍历数据 生成树状结构
        $tree = array();
        foreach($items as $key => $value){
            if(isset($items[$value['pid']])){
                $items[$value['pid']]['son'][] = &$items[$key];
            }else{
                $tree[] = &$items[$key];
            }
        }
        return $tree;
    }

    /**
     * 递归实现无限极分类
     * @param $array
     * @param int $pid
     * @param int $level
     * @return array
     */
    public function getTree($array, $pid =0, $level = 0){
        //声明静态数组,避免递归调用时,多次声明导致数组覆盖
        static $list = [];
        foreach ($array as $key => $value){
            //第一次遍历,找到父节点为根节点的节点 也就是pid=0的节点
            if ($value['pid'] == $pid){
                //父节点为根节点的节点,级别为0，也就是第一级
                $value['level'] = $level;
                //把数组放到list中
                $list[] = $value;
                //把这个节点从数组中移除,减少后续递归消耗
                unset($array[$key]);
                //开始递归,查找父ID为该节点ID的节点,级别则为原级别+1
                $this->getTree($array, $value['id'], $level+1);

            }
        }
        return $list;
    }


}